# Пояснения к выполненному заданию

Я сделал исходник статьи на Asciidoc и сгенерировал из него DocBook и страницу html.
Чтобы увидеть результат, можно просто скачать страницу `oops.html` и открыть ее в браузере.

Чтобы собрать страницу из исходников, нужно клонировать проект и запустить asciidoctor с дефолтными настройками:

```sh
git clone https://github.com/abogdanov85/Postgrespro_Task.git
cd Postgrespro_Task
asciidoctor oops.adoc
```
(Должен быть установлен asciidoctor и highlight.js.)

Чтобы получить DocBook, нужно запустить asciidoctor в режиме бэкенда DocBook:

```sh
asciidoctor -b docbook oops.adoc
```

Предпросмотр файлов `.adoc` на Github полноценно не работает, так как у них не поддерживаются выражения `include` и некоторые другие объекты Asciidoc.

## Описание файлов проекта:
* `oops.adoc` — исходный файл статьи
* `templates/parameter_definition.adoc` — шаблон для параметров
* `templates/docstring.adoc` — шаблон для описания функций (докстрингов)
* `docstrings/function_create_projection.adoc` — описание (докстринг) функции `create_projection`
* `oops.html` — html страница статьи
* `oops_version2.html` — html страница статьи в версии 2 (подробнее про версии см. [ниже](#условные-конструкции-для-поддержки-версионирования))
* `oops.xml` — статья в виде DocBook
* `oops_version2.xml` — статья в версии 2 в виде DocBook

## Общие соображения

Исходный текст задания — это документ pdf, и поэтому первым делом нужно было скопировать текст и разбить его на предложения, удалив лишние переносы строк.
Далее пришлось восстановить разметку литеральных фрагментов в тексте и сделать однообразное форматирование в блоках кода (отступы по 4 пробела, однообразное разделение на строки и т.п.).
Некоторые фрагменты текста я переписал довольно значительно (например, описание параметров функции), а в некоторых только исправил грамматические ошибки и постарался улучшить стиль.

В каких-то смысловых правках я не очень уверен, и в таких случаях я помечал это в комментариях в исходном файле `oops.adoc`.

## Выбор Asciidoc для исходных файлов

Я использовал Asciidoc, так как достаточно хорошо с ним знаком и мне нравится, какие возможности он предоставляет для создания технической документации.
Я сделал довольно сложную структуру проекта — отдельные файлы с шаблонами, отдельный файл с описанием функций и т.п.
Конечно, если задача состоит только в написании одной статьи, то такая сложная структура - это лишнее.
Но я исходил из того, что эта статья — часть большого проекта, в котором у нас есть много статей, много функций или других объектов для описания.
В таком случае шаблонизация и другие средства для унификации описаний очень полезны.

В файлах `adoc` есть мои комментарии для каждого объекта.
А общие соображения я описываю в этом README.

## Как работают файлы шаблонов и описаний функций

Идея состоит в том, чтобы максимально унифицировать документацию проекта и по возможности обеспечить единственное место описания для всех повторяющихся элементов.

В тексте статьи мы имеем подробное описание одной функции — `create_projection`.
Предположим, что таких объектов (функций, методов, констант, ключевых слов и т.п.) у нас много.
В таком случае очень полезно иметь стандартный шаблон для их описания, заданный в одном месте, чтобы на финальных страницах они выглядели однообразно, и чтобы при необходимости можно было поменять этот шаблон в одном месте для всех таких объектов.

Часто в языках программирования описания функций делаются в виде докстринга (docstring) непосредственно в программном коде, а потом импортируются в документацию.
Поэтому я использую этот термин здесь и в самом проекте.

Шаблон для докстрингов сделан в файле `templates/docstring.adoc`.
Он используется в файле `docstrings/function_create_projection.adoc` через тэги и  может использоваться для описания других объектов.
На вход он принимает два атрибута: имя объекта (`object_name`) и его тип (`object_type`).
Этот докстринг вынесен в отдельный файл в папке `docstrings`. 
Предполагается, что в этой папке будут отдельные файлы с описаниями всех подобных объектов.
В таком случае их удобно использовать на любых страницах проекта (через `include`), а при необходимости можно сгенерировать одну страницу (или один раздел) со описаниями всех функций модуля.
Обычно такие страницы называют "Справочник по API" или "Index" или просто "API".

В описании функции есть повторяющиеся элементы - это описания ее параметров.
Их я тоже сделал через шаблон, который описан в файле `templates/parameter_definition.adoc`.
Шаблон принимает на вход 4 атрибута: 
* `parameter_name` — имя параметра
* `parameter_value` — тип значения параметра
* `parameter_is_optional` — является ли параметр опциональным (если нет, то атрибут остается пустым)
* `parameter_description` — описание параметра

Все эти атрибуты верстаются в единый элемент списка `<dd>` (description definition).
Я сделал именно список `<dd>`, так как заметил, что вы часто используете такие списки в вашей документации, например, [здесь](https://postgrespro.ru/docs/postgresql/13/queries-table-expressions).
Если нужно будет поменять верстку для параметров, например сделать вместо списка `<dd>` таблицу или что-то другое, то это можно будет сделать в одном месте — в файле шаблона, и верстка применится ко всем параметрам в описании всех объектов.

Все элементы всех шаблонов подробно прокомментированы в исходных файлах `adoc`.

## Условные конструкции для поддержки версионирования

В тексте статьи говорится о том, что некоторая функциональность будет доступна только в будущем, а в данный момент нужно использовать другой инструмент (функцию вместо простой записи командой SQL).
В целом мне не кажется правильным делать такие "обещания" в технической документации (так как они могут не сбыться никогда или сбыться, но в другой реализации).
Но я не стал удалять этот фрагмент, а сделал разные версии этого текста для случаев, когда эта функциональность еще не готова и когда уже готова.
Для этого я использовал условные конструкции Asciidoc (`ifeval` в файле `oops.adoc`), проверяющие номер версии.

Понятно, что в реальном мире привязать варианты текста статьи к версиям релиза будет не очень просто, и, скорее всего, проще будет переписать статью, но здесь я сделал условные конструкции для демонстрации возможностей Asciidoc.
Подробные комментарии про версии разных фрагментов есть в исходниом файле `oops.adoc`.

Чтобы собрать статью в версии 2, можно переопределить атрибут в командной строке:

```sh
asciidoctor -a version=2 oops.adoc -o oops_version2.html
```
Чтобы получить DocBook версии 2, нужно сделать аналогично:

```sh
asciidoctor -a version=2 -b docbook oops.adoc -o oops_version2.xml
```

## Одна строка — одно предложение

В файлах `adoc` и в этом тексте (в формате Markdown) я использую конвенцию "One sentence per line" (одна строка — одно предложение), так как я считаю ее очень полезной и удобной.
Преимущества такого метода перечислены например [здесь](https://nick.groenen.me/notes/one-sentence-per-line/).

У меня большой опыт различных работ с исходниками в Asciidoc и Markdown (конвертация, автоматический перевод, автоматическая вставка контента) и во всех таких задачах этот метод был очень полезен.

## Выделения `productname`

В тексте статьи встречаются фрагменты, которые можно условно объединить в категорию коммерческих названий: "OOPS", "SQL".
Для таких фрагментов я использовал кастомный класс (роль) `productname`, так как я заметил, что вы используете такой класс для некоторых коммерческих названий продуктов в вашей документации.

При этом у вас, например [здесь](https://postgrespro.ru/docs/postgrespro/17/intro-whatis), такие фрагменты внешне на финальной странице никак не выделены.
Хотя на мой взгляд выделить их хотя бы просто жирным было бы полезно.

Я хочу подчернкуть, что я на собственном опыте хорошо знаю, насколько плохо использовать одни и те же выделения для фрагментов разных типов.
Например, в некоторых проектах, где я работал, жирным в текстах могли быть выделены самые разные фрагменты, в том числе смысловые: "**очень** сильно", "**только** в этом случае" наряду с коммерческими названиями.
И если использовать одинаковые выделения для таких разных случаев, то в будущем нас могут ждать неприятные последствия такого решения — например, если мы захотим для всех коммерческих названий сделать ссылки на их веб-страницы, то мы уже не сможем простым способом найти в наших документах только коммерческие названия, так как они будут смешаны с фрагментами другого типа, для которых ссылки не нужны (**очень**, **только**).

А если вы, например, захотите сделать автоматический перевод ваших документов, то для этой задачи тоже нужно по возможности иметь разные выделения фрагментов для разных их типов — какие-то из этих типов должны переводиться, а какие-то должны блокироваться от перевода.

Поэтому любые выделения в исходных документах должны производиться системно и осмысленно, и мне приятно видеть, что у вас используются осмысленные классы для таких случаев.
У меня очень большой опыт работы с массивами старых исходных документов, которые писались несистемно и где, например, жирным выделялись самые разные типы фрагментов: смысловые фрагменты (**очень**, **только**), системные имена (функция **copy**), коммерческие названия (сервер **Gitlab**) и т.д.
В некоторых случаях весь документ проще было переписать с нуля, чем исправлять все такие случаи.

При этом само внешнее отображение разных типов фрагментов на финальной странице может быть одинаковое.
Важно только, чтобы в исходной структуре типы фрагментов различались.
Поэтому в этой статье я для демонстрации этой идеи специально настроил css для фрагментов типа `commercial` на обычный жирный шрифт.
Конечно, css нужно настраивать на уровне всего проекта, здесь я сделал это в демонстрационных целях.

Еще я заметил, что некоторые коммерческие названия у вас не выделены никак.
Например, [на этой странице](https://postgrespro.ru/docs/postgrespro/17/config-one-c) много фрагментов "1С", и для них нет никаких выделений.
Возможно, это потому, что вы выделяете названия только своих продуктов.

## Подсветка синтаксиса в блоках кода

Разные JOIN
https://www.postgresql.org/docs/13/explicit-joins.html

## Отдельные блоки вывода


