# Пояснения к выполненному заданию

Я сделал исходник статьи на Asciidoc и сгенерировал из него DocBook и страницу html.
Чтобы увидеть результат, можно просто скачать страницу `oops.html` и открыть ее в браузере.

Чтобы собрать страницу из исходников, нужно клонировать проект и запустить asciidoctor с дефолтными настройками:

```sh
git clone https://github.com/abogdanov85/Postgrespro_Task.git
cd Postgrespro_Task
asciidoctor oops.adoc
```
(Должен быть установлен asciidoctor и highlight.js.)

Чтобы получить DocBook, нужно запустить asciidoctor в режиме бэкенда DocBook:

```sh
asciidoctor -b docbook oops.adoc
```

Предпросмотр файлов `.adoc` на Github полноценно не работает, так как у них не поддерживаются выражения `include` и некоторые другие объекты Asciidoc.

## Описание файлов проекта

* `oops.adoc` — исходный файл статьи
* `templates/parameter_definition.adoc` — шаблон для параметров
* `templates/docstring.adoc` — шаблон для описания функций (докстрингов)
* `docstrings/function_create_projection.adoc` — описание (докстринг) функции `create_projection`
* `dictionary.adoc` — файл словаря для продуктовых названий и других выражений
* `oops.html` — html страница статьи
* `oops_version2.html` — html страница статьи в версии 2 (подробнее про версии см. [ниже](#условные-конструкции-для-поддержки-версионирования))
* `oops.xml` — статья в виде DocBook
* `oops_version2.xml` — статья в версии 2 в виде DocBook

## Общие соображения

Исходный текст задания — это документ pdf, и поэтому первым делом нужно было скопировать текст и разбить его на предложения, удалив лишние переносы строк.
Далее пришлось восстановить разметку литеральных фрагментов в тексте и сделать однообразное форматирование в блоках кода (отступы по 4 пробела, однообразное разделение на строки и т.п.).
Некоторые фрагменты текста я переписал довольно значительно (например, описание параметров функции), а в некоторых только исправил грамматические ошибки и постарался улучшить стиль.

В каких-то смысловых правках я не очень уверен, и в таких случаях я помечал это в комментариях в исходных файлах `adoc`.

Мне не удалось найти расшифровку аббревиатуры "OOPS". 
Если это название является реальным (а не выдуманным для этого задания), то на мой взгляд, оно не очень удачное, так как оно омонимично английскому слову "oops" с довольно негативным значением.
Плюс к этому его будет сложно искать в поисковых системах из-за такой омонимии.

## Выбор Asciidoc для исходных файлов

Я использовал Asciidoc, так как достаточно хорошо с ним знаком и мне нравится, какие возможности он предоставляет для создания технической документации.
У него очень активное и живое сообщество авторов.
Я за последние несколько лет неоднократно обращался с разными вопросами к участникам форумов и чатов по Asciidoc, и чаще всего на мои вопросы отвечали сами разработчики, причем в течение нескольких часов.

Я сделал довольно сложную структуру проекта — отдельные файлы с шаблонами, отдельный файл с описанием функций, файл словаря, вложенные выражения `include`, тэги.
Конечно, если задача состоит только в написании одной статьи, то такая сложная структура — это лишнее.
Но я исходил из того, что эта статья — часть большого проекта, в котором есть много статей и много функций или других объектов для описания.
В таком случае шаблонизация и другие средства для унификации описаний очень полезны.

В файлах `adoc` есть мои комментарии для каждого объекта.
А общие комментарии я записал в этом README.

## Как работают файлы шаблонов и описаний функций

Идея состоит в том, чтобы максимально унифицировать документацию проекта и по возможности обеспечить единственное место описания для всех повторяющихся элементов.

В тексте статьи мы имеем подробное описание одной функции — `create_projection`.
Предположим, что таких объектов (функций, методов, констант, ключевых слов и т.п.) у нас много.
В таком случае полезно иметь стандартный шаблон для их описания, заданный в одном месте, чтобы на финальных страницах они выглядели однообразно, и чтобы при необходимости можно было поменять этот шаблон в одном месте для всех таких объектов.

Часто в языках программирования описания функций делаются в виде докстринга (docstring) непосредственно в программном коде, а потом импортируются в документацию.
Поэтому я использую этот термин здесь и в самом проекте.

Шаблон для докстрингов сделан в файле `templates/docstring.adoc`.
Он используется в файле `docstrings/function_create_projection.adoc` через тэги и  может использоваться для описания других объектов.
На вход он принимает два атрибута: имя объекта (`object_name`) и его тип (`object_type`).
Этот докстринг вынесен в отдельный файл в папке `docstrings`.
Блок докстринга имеет специальный класс `docstring`, по которому можно настроить для него отдельное оформление (например, обводку и заливку фона).
Я для простоты и в целях демонстрации сделал оформление этого блока горизонтальными линиями.

Предполагается, что в папке `docstrings` будут отдельные файлы с описаниями всех подобных объектов.
В таком случае их удобно использовать на любых страницах проекта (через `include`), а при необходимости можно сгенерировать одну страницу (или один раздел) с описаниями всех функций модуля.
Обычно такие страницы называют "Справочник по API" или "Index" или просто "API".

В описании функции есть повторяющиеся элементы - это описания ее параметров.
Их я тоже сделал через шаблон, который описан в файле `templates/parameter_definition.adoc`.
Шаблон принимает на вход 4 атрибута: 
* `parameter_name` — имя параметра
* `parameter_value` — тип значения параметра
* `parameter_is_optional` — является ли параметр опциональным (если нет, то атрибут остается пустым)
* `parameter_description` — описание параметра

Все эти атрибуты верстаются в единый элемент списка `<dd>` (description definition).
Я сделал именно список `<dd>`, так как заметил, что вы часто используете такие списки в вашей документации, например [здесь](https://postgrespro.ru/docs/postgresql/13/queries-table-expressions).
Если нужно будет поменять верстку для параметров, например сделать вместо списка `<dd>` таблицу или что-то другое, то это можно будет сделать в одном месте — в файле шаблона, и верстка применится ко всем параметрам в описании всех объектов.

Все элементы всех шаблонов подробно прокомментированы в исходных файлах `adoc`.

## Условные конструкции для поддержки версионирования

В тексте статьи говорится о том, что некоторая функциональность будет доступна только в будущем, а в данный момент нужно использовать другой инструмент (функцию вместо простой записи командой SQL).
В целом мне не кажется правильным делать такие "обещания" в технической документации (так как они могут не сбыться никогда или сбыться, но в другой реализации).
Но я не стал удалять этот фрагмент, а сделал разные версии этого текста для случаев, когда эта функциональность еще не готова и когда уже готова.
Для этого я использовал условные конструкции Asciidoc (`ifeval` в файле `oops.adoc`), проверяющие номер версии.

Понятно, что в реальном мире привязать варианты текста статьи к версиям релиза будет не очень просто, и, скорее всего, проще будет переписать статью, но здесь я сделал условные конструкции для демонстрации возможностей Asciidoc.
Подробные комментарии про версии разных фрагментов есть в исходниом файле `oops.adoc`.

Чтобы собрать статью в версии 2, можно переопределить атрибут в командной строке:

```sh
asciidoctor -a version=2 oops.adoc -o oops_version2.html
```
Чтобы получить DocBook версии 2, нужно выполнить аналогичную команду:

```sh
asciidoctor -a version=2 -b docbook oops.adoc -o oops_version2.xml
```

## Одна строка — одно предложение

В файлах `adoc` и в этом тексте (в формате Markdown) я придерживаюсь конвенции "One sentence per line" (одна строка — одно предложение), так как я считаю ее очень полезной и удобной.
Преимущества такого метода перечислены, например, [здесь](https://nick.groenen.me/notes/one-sentence-per-line/).

У меня большой опыт различных работ с исходниками в Asciidoc, Markdown и ipynb (конвертация, автоматический перевод, автоматическая вставка контента), и во всех таких задачах этот метод был очень полезен.

## Класс `productname`

В тексте статьи встречаются фрагменты, которые можно условно объединить в категорию коммерческих названий: "OOPS", "SQL".
Для таких фрагментов я использовал кастомный класс (роль) `productname`, так как я заметил, что вы используете такой класс для некоторых коммерческих названий продуктов в вашей документации.

При этом у вас, например [здесь](https://postgrespro.ru/docs/postgrespro/17/intro-whatis), такие фрагменты внешне на финальной странице никак не выделены.
Хотя на мой взгляд выделить их хотя бы просто жирным было бы полезно.

Я хочу подчеркнуть, что я на собственном опыте хорошо знаю, насколько плохо использовать одни и те же выделения для фрагментов разных типов.
Например, в некоторых проектах, где я работал, жирным в текстах могли быть выделены самые разные фрагменты, в том числе смысловые: "**очень** сильно", "**только** в этом случае" наряду с коммерческими названиями и программными именами ("сервер **Gitlab**", "функция **copy**").
И если использовать одинаковые выделения для таких разных случаев, то в будущем нас могут ждать неприятные последствия такого решения — например, если мы захотим для всех коммерческих названий сделать ссылки на их веб-страницы, то мы уже не сможем простым способом найти в наших документах только коммерческие названия, так как они будут смешаны с фрагментами другого типа, для которых ссылки не нужны ("**очень**", "**только**").

Поэтому любые выделения в исходных документах должны производиться системно и осмысленно, и мне приятно видеть, что у вас используются осмысленные классы для таких случаев.
У меня очень большой опыт работы с массивами старых исходных документов, которые писались несистемно и где, например, жирным выделялись самые разные типы фрагментов: смысловые фрагменты, программные имена, коммерческие названия и многое другое.
В некоторых случаях весь документ проще было переписать с нуля, чем исправлять все такие вхождения.

При этом внешнее отображение разных типов фрагментов на финальной странице может быть одинаковое.
Важно только, чтобы в исходной структуре типы фрагментов различались.
Поэтому в этой статье я для демонстрации этой идеи специально настроил css для фрагментов типа `commercial` на обычный жирный шрифт.
Конечно, css нужно настраивать на уровне всего проекта, здесь я сделал это в демонстрационных целях.

Еще я заметил, что некоторые коммерческие названия у вас не выделены никак.
Например, [на этой странице](https://postgrespro.ru/docs/postgrespro/17/config-one-c) много фрагментов "1С", и для них нет никаких выделений.
Возможно, это потому, что вы выделяете названия только своих продуктов.

## Использование файла словаря

Я сделал отдельный файл словаря (`dictionary.adoc`), чтобы показать, как в Asciidoc можно использовать словари.
В данном случае в словаре всего два входа, но он все равно полезен, так как мы в одном месте можем поменять тип выделения для всех вхождений объектов, которые в нем перечислены (например, изменить им роль, удалить ее, добавить url для ссылки и т.п.).

По моему опыту, это очень удачное решение, которое позволяет упростить работу техническим писателям — им в таком случае не нужно задумываться об этом и помнить, каким образом выделяются те или иные фрагменты, они должны просто использовать в тексте атрибуты вида `{oops}`, `{sql}`, `{postgrespro}`, а как эти фрагменты должны быть оформлены, определяется в словаре, и за это может отвечать один человек, независимый от технических писателей (руководитель группы, редактор).

## Подсветка синтаксиса в блоках кода

На мой взгляд, подсветка синтаксиса в блоках кода очень полезна для восприятия технических текстов, особенно для читателя, который является новичком.
Поэтому я удивлен тем, что ни в [вашей документации](https://postgrespro.ru/docs/postgresql/13/preface), ни в [документации postgresql](https://www.postgresql.org/docs/13/preface.html) я не нашел блоков кода с подсветкой синтаксиса.

Я сделал на блоках кода метку языка `sql`, и подсветка у меня работает (с использованием стандартного пакета highlight.js), хотя я понимаю, что на некоторых блоках правильнее было бы использовать метку языка `postgres`.
Но поскольку она поддерживается в гораздо меньшем количестве приложений и сервисов (например, в предпросмотре Github, как я понял, `postgres` не поддерживается), то я остановился на `sql`.

Понятно, что если вводить подсветку синтаксиса, то это надо делать системно, и сначала решить, можем ли мы использовать `postgres` на ряду с `sql` или нет.
Но в любом случае, мне кажется, что подсветка кода в документации должна быть.

Кстати, на [вики-ресурсе postgresql](https://wiki.postgresql.org/wiki/Main_Page) подсветка используется, но не во всех случаях.
Например, на [этой странице](https://wiki.postgresql.org/wiki/Fixing_Sequences) она есть, а на [этой](https://wiki.postgresql.org/wiki/Database_Schema_Recommendations_for_an_Application) — нет.
Понятно, что в документации open source проекта документация часто может быть неединообразной.

Я также заметил, что в блоках кода в вашей документации нет всплывающей кнопки `Copy` в углу блока, которая стала уже стандартом де-факто в мире технической документации.
Она есть на этой странице, если вы читаете ее в режиме предпросмотра Github.
Думаю, было бы здорово добавить и ее на страницы вашей документации.

Еще я пытался найти в [документации postgresql](https://www.postgresql.org/docs/13/preface.html), как у них принято записывать и оформлять в тексте команды типа "JOIN" во множественном числе - "JOINs" или "joins" или, может быть `JOIN`s, и нашел [страницу](https://www.postgresql.org/docs/13/explicit-joins.html), на которой встречается разные варианты в одинаковом контексте: "explicit JOINs" и "explicit joins".
Я остановился на "JOINs".

## Отдельные блоки вывода

В конце статьи есть довольно длинный блок кода, в котором, как я понял, показывается разница во времени исполнения одних и тех же операций с использованием OOPS и без использования.
Но в этом блоке, насколько я понял, нет программных выводов, на которых собственно мы могли бы увидеть разницу.
Возможно, это было частью задания — понять, что там их нет.
Если это не так, то я не понимаю, почему их там нет.

Я добавил в него комментарии и разделил его на две части, после каждой из которых, как я понимаю, должен быть программный вывод.
Я добавил блоки с программным выводом с условным текстов внутри и показал (через кастомный класс css), что было бы удобно, если бы эти блоки имели другое внешнее оформление по сравнению с блоками ввода.
К сожалению, в Asciidoc нет специальных средств для оформления блоков вывода.

Мне кажется важной эта деталь, так как я много работал с ноутбуками ipynb и другими типами документов, где используется разное оформление для блоков ввода и вывода, обычно идущих друг за другом.
Если таких пар на странице много и между ними нет текста, то при одинаковом оформлении легко запутаться, где ввод, а где вывод.
Тем более, что не у каждого блока ввода должен быть блок вывода.

Например, [вот как](https://docs.sciml.ai/DiffEqDocs/stable/tutorials/advanced_ode_example/) оформляются блоки ввода и вывода в документации по пакету DifferentialEquations программного языка Julia, с документацией которого я много работал.
Для них просто используется разный цвет фона, и сразу же "читаемость" такой страницы сильно улучшается.

У вас в документации я нашел разные способы оформления блоков вывода, причем иногда эти разные способы имеются на одной странице.
Например, [здесь](https://postgrespro.ru/docs/postgresql/13/tutorial-join) первая таблица с колонками `city|temp_lo|...` дана в отдельном блоке кода, а вторая аналогичная таблица дана в том же блоке, что и программный ввод.
А вот [в этом разделе на другой странице](https://postgrespro.ru/docs/postgresql/13/sql-syntax-calling-funcs#SQL-SYNTAX-CALLING-FUNCS-POSITIONAL) использован третий тип оформления программных выводов — они даны в тех же блоках, что и ввод, но без пустой строки между ними.
Мне кажется, это недоработка.
Даже если вы не используете отдельный тип оформления для блоков вывода, то все равно их нотация должна быть однообразной.
